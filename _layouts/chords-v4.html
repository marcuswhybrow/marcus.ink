<!doctype html>
<html lang="en">
  <head>
    <title>{{ page.song_title }} &bull; Marcus Whybrow</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="description" content="{{ page.song_title }}{% if page.song_author %} by {{ page.song_author }}{% endif %}.">

    <style>
      #notation {
        display: none;
      }
      #render {
        border-bottom: 10px solid black;
      }
      #render .bar {
        display: inline-block;
        border-left: 1px solid rgb(202, 202, 202);
        margin: 10px 0;
      }
      #render .bar.bar-double {
        position: relative;
        border-left: 1px solid rgb(180, 180, 180);
        /* background-color: rgb(230, 230, 230); */
      }
      #render .bar.bar-double:after {
        content: " ";
        position: absolute;
        z-index: -1;
        top: -0;
        left: 2px;
        width: 1px;
        bottom: 0;
        background-color: rgb(180, 180, 180);
      }
      #render .bar .beat {
        display: inline-block;
        vertical-align: top;
      }
      #render .bar.bar.bar-double .beat:first-child .voice {
        padding-left: 8px;
      }
      #render .bar .beat:first-child .voice {
        padding-left: 5px;
      }
      

      #render .bar .beat .instrument {
        padding: 5px 0;
        margin: 10px 0;
      }
      #render .instrument.instrument-single-voice {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 11px;
      }
      #render .instrument.instrument-multi-voice {
        font-family: monospace;
      }
      #render .bar .beat .instrument:first-child {
        margin-top: 0;
      }
      #render .bar .beat .instrument:last-child {
        margin-bottom: 0;
      }
      #render .bar .beat .instrument:nth-child(odd) {
        /* background-color: rgb(238, 238, 238);  */
      }
      #render .bar .beat .instrument .voice {
        position: relative;
        height: 15px;
        padding-right: 5px;
      }
      #render .bar .beat .instrument .voice:after {
        content: " ";
        position: absolute;
        z-index: -1;
        top: 8px;
        left: 0;
        right: 0;
        height: 1px;
        background-color: rgb(235, 235, 235);
      }
      #render .bar .beat .instrument .voice span {
        background-color: white;
        padding: 0 3px;
      }
      
    </style>
  </head>
  <body>
    <!-- <a id="banner" href="./">Songs</a> -->

    <article>
      <header>
        {% assign slug = page.url | split: '/' | last | split: '.' | first %}
        <h1 class="{{ slug }}">{{ page.song_title }}</h1>
        {% if page.song_author %}<address>{{ page.song_author }}</address>{% endif %}
      </header>

      <div id="render">
      </div>


<pre id="notation">{{ content }}</pre>
    </article>
  </body>

  <script type="application/javascript">
    class Piece {
      constructor(notationLiteral) {
        this.parser = new Parser(notationLiteral);
        console.log(this.parser);
      }

      render(element) {
        this.parser.bars.map(bar => {
          const barElement = document.createElement("div");
          barElement.className = "bar";
          switch (bar[0]) {
            case "|": barElement.className += " bar-single"; break;
            case "||": barElement.className += " bar-double"; break;
            case "/||": barElement.className += " bar-double-bold"; break;
          }
          bar.slice(1).map(beat => {
            const beatElement = document.createElement("div");
            beatElement.className = "beat";
            const names = {};
            for (let [name, voiceCount] of Object.entries(this.parser.names)) {
              const instrumentElement = document.createElement("div");
              instrumentElement.className = "instrument";
              instrumentElement.setAttribute("data-name", name);
              instrumentElement.setAttribute("data-voice-count", voiceCount);
              instrumentElement.className += (voiceCount === 1) ? " instrument-single-voice" : " instrument-multi-voice";

              for (let i = 0; i < voiceCount; i++) {
                const voiceElement = document.createElement("div");
                voiceElement.className = "voice";
                voiceElement.setAttribute("data-instrument-name", name);
                voiceElement.setAttribute("data-voice", i + 1);
                try {
                  const voiceSpanElement = document.createElement("span");
                  const text = beat[name][i];
                  if (text) {
                    voiceSpanElement.textContent = text;
                    voiceElement.appendChild(voiceSpanElement);
                  }
                } catch(e) {
                  voiceElement.className += " voice-rest";
                }
                instrumentElement.appendChild(voiceElement);
              }
              beatElement.appendChild(names[name] = instrumentElement);
            }
            barElement.appendChild(beatElement);
          });
          element.appendChild(barElement);
        });
      }
    }
    class Parser {
      constructor(input) {
        this.names = {};
        this.chunks = this._parseText(input);
        this.bars = this._deriveBars(this.chunks);
      }

      parseName(input) {
        // Empty input
        if (!input)
          return null;
        const match = input.match(/(.+)\.$/);
        // Unabbreviated input
        if (!match) {
          this.names[input] = 0;
          return [input];
        }
        // Abbreviated input
        return Object.keys(this.names).filter(n => n.indexOf(match[1]) === 0);
      }
      registerVoiceCount(name, voiceCount) {
        this.names[name] = Math.max(this.names[name], voiceCount);
      }

      _parseText(input) {
        const chunks = input.split(/(\n[\s\n]*\n)/);
        let groups = [];
        let position = 1;
        for (let chunkId = 0; chunkId < chunks.length;) {
          const chunk = chunks[chunkId++];
          const nextChunk = chunks[chunkId++];
          let chunkTail = 0;
          if (nextChunk) {
            if (nextChunk.match(/^\n[\s\n]*\n$/)) {
              chunkTail = (nextChunk.match(/\n/g) || []).length - 1;
            } else {
              // Not sure this can even occure!
              // There cannnot be a subsequent notationSection without trail blank lines.
              console.error("Formatting error: Notation group not followed by at least one blank line.");
            }
          }
          const newChunk = new Parser.Chunk(this, position, chunk, chunkTail);
          groups.push(newChunk);
          position += newChunk.height + chunkTail;
        }
        return groups;
      }
      _deriveBars(chunks) {
        return chunks
          .map((chunk, chunkId) => {
            const finalBar = chunk.bars[chunk.bars.length - 1];
            if (finalBar.length > 1) // No closing barline
              return chunk.bars;
            const nextChunk = chunks[chunkId + 1];
            if (nextChunk && nextChunk.bars[0][0] !== finalBar[0])
              chunk.error("Closing barline incorrect");
            return chunk.bars.slice(0, chunk.bars.length - 1);
          })
          .reduce((accum, bars) => accum.concat(bars));
      }
    }
    Parser.Chunk = class {
      constructor(parser, position, literal, tail) {
        this.parser = parser;
        this.position = position;
        this.literal = literal;
        this.tail = tail;
        this.lines = this.literal.split(/\s*\n/);
        this.height = this.lines.length;
        this.width = Math.max(...this.lines.map(line => line.length));
        this.gutters = this._deriveGutters(this.lines);
        this.columns = this._deriveColumns(this.gutters, this.lines);
        this.bars = this._parseColumns(this.columns);
      }

      error(msg, lineId, columnNumber) {
        let location = "";
        if (lineId !== undefined) {
          location += ` on line ${this.position + lineId}`;
          if (columnNumber !== undefined)
            location += ` column ${columnNumber}`
        } else {
          location += ` in section beginning on line ${this.position}`;
        }
        console.error(`${msg}${location}.\n\n${this._deriveDebugString()}\n\n`);
      }
      _deriveDebugString() {
        const maxTagWidth = (this.position + this.height - 1).toString().length;
        return this.lines.map((line, lineId) => {
          const linePosition = this.position + lineId;
          const lineTag = linePosition.toString().padStart(maxTagWidth + 1, "0");
          return `${lineTag}: ${line}`;
        }).join("\n");
      }

      _deriveGutters(lines) {
        const re = /\s/g;
        return lines.map(line => {
          let match;
          const positions = [];
          while(match = re.exec(line))
            positions.push(match.index);
          return positions;
        }).reduce((result, gutterPositions) => {
          return result.filter(pos => gutterPositions.includes(pos))
        });
      }

      _deriveColumns(gutterPositions, lines) {
        const firstColumn = [lines.map(line => line.substring(0, gutterPositions[0]))];
        return firstColumn.concat(gutterPositions.map((pos, i, ar) => {
          return lines.map(line => line.substring(pos + 1, ar[i + 1]));
        }));
      }

      _isBarLine(column) {
        return column.every(line => line === column[0]) && column[0].match(/^\/?\|\|?$/);
      }

      _parseColumns(input) {
        const columns = input.slice();
        let column;
        // Consume names
        let columnsBuffer = [];
        while(column = columns.shift()) {
          if(this._isBarLine(column)) break;
          columnsBuffer.push(column);
        }
        const nameLines = columnsBuffer.reduce((accum, col) => accum.map((text, i) => `${text} ${col[i]}`));
        const names = [];
        nameLines.map((text, lineId, lines) => {
          const trimText = text.trim();
          if (!trimText) {
            const name = names[lineId - 1][0];
            const voiceId = names[lineId - 1][1] + 1;
            names[lineId] = [name, voiceId];
            this.parser.registerVoiceCount(name, voiceId + 1);
            return;
          }
          const matches = this.parser.parseName(trimText);
          switch (matches.length) {
            case 1:
              names[lineId] = [matches[0], 0];
              this.parser.registerVoiceCount(matches[0], 1);
              return;
            case 0:
              this.error(`Abbreviated instrument name "${trimText}" matched no established instrument name`, lineId, 0);
              names[lineId] = [null, 0];
              return;
            default:
              this.error(`Abbreviated instrument name "${trimText}" matched more than one instrument names: ${matches}`, lineId, 0);
              names[lineId] = [null, 0];
              return;
          }
        });
        console.log(nameLines);
        const bars = [[column[0]]];
        // Consume bars
        while(column = columns.shift()) {
          if(this._isBarLine(column))
            bars.push([column[0]]);
          else
            bars[bars.length - 1].push(column.map((line, lineId) => {
              return [names[lineId][0], names[lineId][1], line.trim()];
            }).reduce((accum, beat) => {
              if (beat[1] === 0)
                accum[beat[0]] = [];
              accum[beat[0]][beat[1]] = beat[2];
              return accum;
            }, {}));
        }
        return bars;
      }
    }

    var t0 = performance.now();
    var notationElement = document.getElementById("notation");
        notationString = notationElement.textContent;
    new Piece(notationString).render(document.getElementById("render"));

    var t1 = performance.now();
    console.log((t1 - t0) + "ms");
  </script>
</html>
