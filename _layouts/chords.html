<!doctype html>
<html lang="en">
  <head>
    <title>{{ page.song_title }} &bull; Marcus Whybrow</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="description" content="{{ page.song_title }}{% if page.song_author %} by {{ page.song_author }}{% endif %}.">
    <link rel="stylesheet" href="https://use.typekit.net/ydk2vlq.css">
    <link href="https://fonts.googleapis.com/css?family={{ page.song_title_font | replace: ' ', '+' }}&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">

    <style>
      #render {
        font-family: monospace;

        border-bottom: 10px solid black;
      }
      #render .bar {
        display: inline-block;
        border-left: 1px solid rgb(133, 133, 133);
        margin: 10px 0;
      }
      #render .bar.bar-double {
        position: relative;
        border-left: 1px solid rgb(53, 53, 53);
        margin-left: 2px;
        /* background-color: rgb(230, 230, 230); */
      }
      #render .bar.bar-double:after {
        content: " ";
        position: absolute;
        z-index: -1;
        top: -0;
        left: -3px;
        width: 1px;
        bottom: 0;
        background-color: rgb(53, 53, 53);
      }
      #render .bar .beat {
        display: inline-block;
        vertical-align: top;
      }
      #render .bar .beat .voice {
        height: 15px;
      }

      #render .bar .beat .instrument {
        padding: 5px 0;
        margin: 10px 0;
      }
      #render .bar .beat .instrument:first-child {
        margin-top: 0;
      }
      #render .bar .beat .instrument:last-child {
        margin-bottom: 0;
      }
      #render .bar .beat .instrument:nth-child(odd) {
        background-color: rgb(238, 238, 238); 
      }
      
    </style>
  </head>
  <body>
    <!-- <a id="banner" href="./">Songs</a> -->

    <article>
      <header>
        {% assign slug = page.url | split: '/' | last | split: '.' | first %}
        <h1 class="{{ slug }}">{{ page.song_title }}</h1>
        {% if page.song_author %}<address>{{ page.song_author }}</address>{% endif %}
      </header>

      <div id="render"></div>

<pre id="notation">{{ content }}</pre>
    </article>
  </body>

  <script type="application/javascript">

    const SYMBOLS = {
      SINGLE_BAR_LINE: '|',
      DOUBLE_BAR_LINE: '||',
      FINAL_BAR_LINE: '/||',
    }

    class Notation {
      constructor(text) {
        this.offset;           // a cursor for parsing through the text.
        this.columns;          // a data structure representing the text as columns.
        this.instruments = []; // list of instrument names derived from text.
        this.barLines;         // positions of barlines in this.columns.

        this._parse(text);
        // console.log(this.columns);
        // this._buildInstruments(this.columns);
        console.log("columns: ", this.columns);
        console.log("instruments: ", this.instruments);
        // console.log(this.barLines);
      }

      _createBarElement(type, offset) {
        const barElement = document.createElement("div");
        barElement.setAttribute("data-offset", offset);
        barElement.className = `bar bar-${type}`;
        return barElement;
      }

      _createBeatElement(column) {
        const beatElement = document.createElement("div");
        beatElement.className = "beat";

        for (const instrumentName in this.instruments) {
          const instrumentBeatVoices = column[instrumentName];
          const instrumentBeatElement = document.createElement("div");
          instrumentBeatElement.className = "instrument";
          instrumentBeatElement.setAttribute("data-voices", 0);
          instrumentBeatElement.setAttribute("data-instrument", instrumentName);

          const intrumentTotalVoices = this.instruments[instrumentName];
          instrumentBeatElement.setAttribute("data-voices", intrumentTotalVoices);

          for (let voiceIndex = 0; voiceIndex < intrumentTotalVoices; voiceIndex++)  {  
            const instrumentBeatVoiceElement = document.createElement("div");
            instrumentBeatVoiceElement.className = "voice";
            instrumentBeatVoiceElement.setAttribute("data-voice", voiceIndex);
            
            if (instrumentBeatVoices) {
              instrumentBeatVoiceElement.appendChild(document.createTextNode(instrumentBeatVoices[voiceIndex]));
            } else {
              instrumentBeatVoiceElement.className += " voice-rest";
            }

            instrumentBeatElement.appendChild(instrumentBeatVoiceElement);
          }

          beatElement.appendChild(instrumentBeatElement);
        }

        return beatElement;
      }

      render(element) {
        let currentBarElement = null;
        for (let i = 0; i <= this.offset; i++) {
          if (this.barLines.hasOwnProperty(i)) {
            switch (this.barLines[i]) {
              case SYMBOLS.SINGLE_BAR_LINE:
              currentBarElement = this._createBarElement("single", i);
              break;

              case SYMBOLS.DOUBLE_BAR_LINE:
              currentBarElement = this._createBarElement("double", i);
              break;

              case SYMBOLS.FINAL_BAR_LINE:
              currentBarElement = this._createBarElement("final", i);
              break;
            }
            element.appendChild(currentBarElement);
          } else {
            if (currentBarElement !== null && this.columns.hasOwnProperty(i)) {
              // console.log(this.columns[i]);
              currentBarElement.appendChild(this._createBeatElement(this.columns[i]));
            }
          }
        }
      }

      _expandInstrumentName(candidateInstrumentName) {
        const match = candidateInstrumentName.match(/(.+)\.$/);
        if (!match) {
          if (candidateInstrumentName) {
            this.instruments[candidateInstrumentName] = 0;
          }
          return {
            literal: candidateInstrumentName,
            proper: candidateInstrumentName,
          };
        }
        const abbreviation = match[1];
        for (const existingInstrumentName in this.instruments) {
          if (existingInstrumentName.indexOf(abbreviation) === 0) {
            return {
              literal: candidateInstrumentName,
              abbreviation: abbreviation,
              proper: existingInstrumentName,
            };
          }
        }
        return {
          literal: candidateInstrumentName,
          abbreviation: abbreviation,
        }
      }

      // _groupTracksByInstrumentName(columns) {
      //   let instruments = {};
      //   for (const columnOffset in columns) {
      //     const column = columns[columnOffset];
      //     for (const instrumentNameLiteral in column) {
      //       const instrumentName = this._expandInstrumentName(instruments, instrumentNameLiteral);

      //       if (!instrumentName.proper) {
      //         console.error(`Abbreviation "${instrumentName.abbreviation}" could not be expanded.`);
      //         instrumentName.proper = instrumentName.literal;
      //       }

      //       instruments[instrumentName.proper] = instruments[instrumentName.proper] || {};
      //       instruments[instrumentName.proper][columnOffset] = column[instrumentName.literal];
      //     }
      //   }
      //   return instruments;
      // }

      // _buildInstruments(columns) {
      //   const instruments = this._groupTracksByInstrumentName(columns);
      //   return instruments;
      //   // return this._translateColumnsToBars(instruments);
      // }

      _parse(text) {
        this.offset = 0;
        this.columns = {};
        this._parseText(text);
        return this.columns;
      }

      _parseText(text) {
        const groupStrings = text.split(/\n[\s\n]*\n/);

        let columns = {};
        let groupOffset = 0;
        for (const i in groupStrings) {
          let group = this._parseGroup(groupStrings[i]);
          for (const j in group.rows) {
            const row = group.rows[j];
            columns[groupOffset + row.columns]
          }
        }


        console.log("_parseText", columns);
        // this.barLines = this._optimiseAndAnalyseColumns();
      }

      _parseGroup(groupString) {
        const rowStrings = groupString.split(/\n/);
        let previousRow;
        let group = {
          maxRowLength: 0,
          rows: [],
        };

        for (const i in rowStrings) {
          const row = this._parseRow(rowStrings[i], previousRow);
          group.rows.push(row);
          group.maxRowLength = Math.max(group.maxRowLength, row.length);

          previousRow = row;

          // Accumulates the max voices defined for any instrument.
          // this.instruments[row.name] = Math.max(this.instruments[row.name], rowVoice);

          // for (const i in rowColumns) {
          //   const column = rowColumns[i];
          //   if (column) {
          //     const columnOffset = this.offset + rowOffset;
          //     this.columns[columnOffset] = this.columns[columnOffset] || [];
          //     this.columns[columnOffset][row.name] = this.columns[columnOffset][row.name] || [];
          //     this.columns[columnOffset][row.name].push(column.trim());
          //     rowOffset += column.length;
          //   }
          // }
        }

        // this.offset += maxRowLength;
        return group;
      }

      _parseColumns(row) {
        return row.split(/([^ ]* +)/);
      }

      _parseRow(rowString, previousRow) {
        let rowStringSplit, row;

        row = {
          string: rowString,
          length: rowString.length,
          instrumentName: null,
          voice: null,
          columns: null,
        };

        if (!rowString) return row;

        rowStringSplit = rowString.split(/^([^\|\/]+)\|+/);
        if (rowStringSplit.length >= 2) {
          const rowName = rowStringSplit[1].trim();
          if (rowName) {
            row.instrumentName = this._expandInstrumentName(rowName).proper;
            row.voice = 1;
            row.columns = rowStringSplit[2].trim().split(/([^ ]+ +)/);
            console.log(row);
          } else {
            if (previousRow) {
              row.instrumentName = previousRow.instrumentName;
              row.voice = previousRow.voice + 1;
            } else {
              console.error(`Cannot find instrument name on this line: "${row.string}`);
            }
          }
        } else {
          console.error(`Bad line format: "${row.string}"`);
        }

        return row;
      }

      _isColumnHomogeneous(column, symbol) {
        for (const instrumentName in column) {
          for (const i in column[instrumentName]) {
            if (column[instrumentName][i] !== symbol) return false;
          }
        }
        
        return true;
      }

      _optimiseAndAnalyseColumns() {
        let cursor, prevColumn, columnWidth, barLines, outputColumns;

        outputColumns = {};
        barLines = {0: SYMBOLS.SINGLE_BAR_LINE};
        cursor = -1;
        for (const columnOffset in this.columns) {
          const column = this.columns[columnOffset];
          const columnWidth = this._getMaxRowWidth(column);

          // console.log(`merge? offset:${columnOffset} cursor:${cursor}`);

          // console.log(columnOffset, column);

          // Does this column intersect with the previous column, if so merge.
          if (columnOffset <= cursor) {
            this._mergeColumns(prevColumn, column);
            delete this.columns[columnOffset];
          } else {
            if (this._isColumnHomogeneous(column, SYMBOLS.SINGLE_BAR_LINE)) {
              barLines[columnOffset] = SYMBOLS.SINGLE_BAR_LINE;
            } else if (this._isColumnHomogeneous(column, SYMBOLS.DOUBLE_BAR_LINE)) {
              barLines[columnOffset] = SYMBOLS.DOUBLE_BAR_LINE;
            } else if (this._isColumnHomogeneous(column, SYMBOLS.FINAL_BAR_LINE)) {
              barLines[columnOffset] = SYMBOLS.FINAL_BAR_LINE;
            }
          }

          cursor = parseInt(columnOffset) + columnWidth;
          prevColumn = column;
        }

        return barLines;
      }

      _getMaxRowWidth(column) {
        let max = 0;
        for (const rowName in column) {
          const intrument = column[rowName];
          for (const trackId in intrument) {
            max = Math.max(max, intrument[trackId].length);
          }
        }
        return max;
      }

      _mergeColumns(firstColumn, secondColumn) {
        for (const rowName in secondColumn) {
          firstColumn[rowName] = firstColumn[rowName] || [];
          for (const i in secondColumn[rowName]) {
            firstColumn[rowName][i] = firstColumn[rowName][i] || "";
            firstColumn[rowName][i] += ` ${secondColumn[rowName][i]}`;
          }
        }
      }

    }

    var t0 = performance.now();

    var notationElement = document.getElementById("notation");
        notationText = notationElement.textContent;
    new Notation(notationText).render(document.getElementById("render"));

    var t1 = performance.now();
    console.log((t1 - t0) + "ms");
  </script>
</html>
